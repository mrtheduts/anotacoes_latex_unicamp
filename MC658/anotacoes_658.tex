\documentclass[a4paper,oneside,article,table]{article}

%encoding
%--------------------------------------
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
%--------------------------------------

%Portuguese-specific commands
%--------------------------------------
\usepackage[brazil]{babel}
%--------------------------------------

%Hyphenation rules
%--------------------------------------
\usepackage{hyphenat}
\hyphenation{mate-mática recu-perar}
%--------------------------------------

%Page formatting
%--------------------------------------
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{multicol}
\usepackage{indentfirst}
\usepackage{enumitem}
%--------------------------------------

%Plotting Graphs
%--------------------------------------
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{graphs}
%--------------------------------------

%Misc
%--------------------------------------
\usepackage[bottom]{footmisc}
\usepackage{array}
\usepackage{microtype}
\usepackage{xparse}
\usepackage{booktabs}
\usepackage{float}
\usepackage{caption}
\usepackage{textcomp}
\usepackage{mdwlist}
\usepackage{subcaption}
%--------------------------------------


\title{Anotações MC658}
\author{Eduardo M. F. de Souza}
\date{\today}

\definecolor{light gray}{gray}{0.8}
\renewcommand{\arraystretch}{1.3}

\frenchspacing
\raggedbottom{}
%\raggedright{}

\begin{document}

\pagenumbering{gobble}
\maketitle

\pagenumbering{arabic}

\tableofcontents
\newpage

\section{Classes de Complexidade}

\subsection{Características}

\begin{itemize}

    \item São classes que contém problemas, e, problemas que contém determinadas características em comum;
    \item A maior parte dos algoritmos vistos até então têm tempo polinomial --- $O(n^k)$ onde $k$ é constante e $n$ é o tamanho da entrada;
    \item Nem todo problema admite um algoritmo polinomial para resolvê-lo. \par
        Exemplo: problema da parada, no qual sequer admite um algoritmo, independente do tempo; programa para predizer se um algoritmo pode entrar em \textit{deadlock} ou não em uma máquina genérica;
        \begin{itemize}
        \item É \textbf{tratável} se admite um algoritmo polinomial;
        \item E \textbf{intratável} se não admitir um algoritmo polinomial (pode admitir um algoritmo exponencial);
    \end{itemize}

\end{itemize}

\subsection{P, NP e NP-Completo (NPC)}

\begin{itemize}
    \item \textbf{P:} Classe em que os problemas que possuem algoritmos que os resolvem em tempo polinomial;
    \item \begin{multicols}{2}
            \textbf{NP:} Classe em que os problemas admitem um algoritmo polinomial que verifiquem instâncias do problema. \par
            Um exemplo é o Ciclo Hamiltoniano:
            \begin{description}
                \item\textit{Entrada:} Grafo simples $G=(V,E)$.
                \item\textit{Saída:} Existe ou não um ciclo que passa por cada vértice exatamente uma vez.
                \item\textit{Verificação:}
                    \par (1,2,3,6,4,5) \textrightarrow{} não é uma solução válida;
                    \par (1,2,3,4,5,6) \textrightarrow{} é uma solução válida;
            \end{description}
            \vfill

        \begin{center}
            \begin{tikzpicture}
                \graph[nodes={circle, draw}, branch down = 1.5cm, grow right = 1.5cm]{
                    2 -- 1 ,
                    2 -- 3 -- 1,
                    3 -- {4 -- 6 -- 1},
                    4 -- 5 -- 6 -- 3;
                };
            \end{tikzpicture}
        \end{center}

    \end{multicols}

    \item \textbf{NP-Completo:} Todo problema desta classe está em NP.\@Problemas NPC têm a característica de, se algum deles admitir um algoritmo polinomial, então automaticamente todos os problemas de NP possuem um algoritmo polinomial;
    
\end{itemize}

\begin{figure}
    \begin{subfigure}{0.5\textwidth}
        \begin{tikzpicture}

            \def\circleNPH{(0,0) circle (2.5cm)}
            \def\circleNP{(0:3cm) circle (1.5cm)}
            \def\circleP{(0:4cm) circle (0.5cm)}

            \draw \circleNPH node[text=black, anchor=east] {NP Difícil};
            \draw \circleNP node[text=black] {NP};
            \draw \circleP node[anchor=east, text=black] {P};

        \end{tikzpicture}
        \caption{P $\neq$ NP}
    \end{subfigure}
    \begin{subfigure}{0.5\textwidth}
        \begin{tikzpicture}

            \def\circleNPH{(0,0) circle (2.5cm)}
            \def\circleNP{(0:1cm) circle (1.5cm)}
            \def\circleP{(0:2cm) circle (0.5cm)}

            \draw \circleNPH node[text=black, anchor=east] {NP Difícil};
            \draw \circleNP node[text=black] {NP};
            \draw \circleP node[anchor=east, text=black] {P};

        \end{tikzpicture}
        \caption{P = NP}
    \end{subfigure}
    \caption*{$\textrm{P} \leq \textrm{NP | NP} \in \textrm{P}$ é uma questão em aberto. Desde 1970 até hoje um importante problema aberto é se $P=NP$.}
\end{figure}

\paragraph{Desde 1970} até hoje um problema importante é se P$=$NP


\subsection{Problemas de Decisão}

Resposta deve ser de Sim (1) ou Não (0).\\
Exemplo:\\
Da versão de decisão do problema do menor caminho em um grafo:
\textit{Entrada:} $G= (V,E)$ com pesos nas arestas, valor k, e uv E V
\textit{Pergunta:} Existe caminho u->v com custo <= k?\\
\subsubsection{Formalização matemática de um problema}
\begin{itemize}
    \item Um problema será definido como um lingagem sobre um alfabeto $\Sigma$;
    \item Usaremos $\Sigma = {0,1}$ (binário);
    \item Dado um problema $Q$, qualquer instância desse problema será codificada como uma string de $0$s e $1$s;
    \item Uma linguagem $L$ de $\Sigma$ é um conjunto de strings formadas com os símbolos de $\Sigma$.\\
        Notação:\\
        \begin{itemize}
            \item E: string vazia
            \item $\emptyset$: Uma linguagem vazia
            \item $\Sigma^*$: Todas as possíveis strings que podem ser escritas com os símbolos de $\Sigma$. Exemplo:\\
                $\Sigma^* = \{E, 0, 1, 00, 01, \ldots\}$
            
        \end{itemize}
        \textit{Observação:} Qualquer lingaguem L é tal que L contem em $\Sigma^*$.
        \textit{Observação:} Qualquer lingaguem L é tal que L contem em $\Sigma^*$.
\end{itemize}

Um problema de decisão $Q$ será visto como uma linguagem que contém todas as strings de $\Sigma^*$ que corresponde às instâncias de $Q$ cuja resposta é sim.\\

Exemplo: Ciclo-Hamiltoniano = \{ $<G = (V, E)>$ tal que G possui um Ciclo Hamiltoniano\}\\
<> : Notação que corresponde à codificação da instância como uma string.

\subsubsection{Operações sobre Linguagens}
União $L_1\orL_2 = \{ s t.q. s \in L_1 ou s \in L_2\}$
Concatenação $L_1\L_2 = \{ xy t.q. x \in L_1 ou y \in L_2\}$
União $L_1 \and L_2 = \{ s t.q. s \in L_1 ou s \in L_2\}$

\subsection{Algoritmos}
\begin{itemize}
    \item Uma entrada para um algoritmo $A$ é qualquer string de $\Sigma^*$;
    \item Um algoritmo aceita $s\in\Sigma^*$ se $A(s)=1$;
    \item Um algoritmo rejeita $s\in\Sigma^*$ se $A(s)=0$;
    \item Um algoritmo aceita uma linguagem $L$ se $\forall s \in L \rightarrow A(s)=1$\\
        Para strings $s \notin L A(s) \neq 1$ o algoritmo pode não parar --- entra em loop infinito)\\
    \item Um algoritmo que decide uma linguagem $L$ se $\forall s \in L \rightarrow A(s) = 1$\\
        $\forall s \notin L \rightarrow A(s) = 0$
    \item Uma linguagem é aceita em tempo polinomial se existe um algoritmo polinomial $A$ que aceita $L$;\\\item Uma linguagem é decidida em tempo polinomial 
    \item Uma linguagem é decidida em tempo polinomial se existe um algoritmo polinomial que decide $L$;

\end{itemize}

    \subsection{Definição da classe P}

        $P = \{ L \in \Sigma^* \text{t.q.} L \text{é decidido em tempo polinomial} \}$\\
        Teorema: P é o conjunto de todas as linguagens decididas em tempo polinomial.\\
        P = {L contido em sigma * tal que L é aceita em tempo polinomial} = P'\\
        Prova:\\
        Contido-) Seja L decidida em tempo polinomial \rightarrow um algoritmo $A$ polinomial que decide $L$ \rightarrow $A$ aceita $L$ em tempo polinomial\\
        Contrário de conntido-) Seja $L$ aceita em tempo polinomial \arrowright Existe um algoritmo $A$ que para todo s pertencente a L $A(s) = 1$ em tempo $c\times|s|^k$ (polinomial) onde $c$ e $k$ são constantes.\\
        Existe um algoritmo $A'$ que simula $A$ por $c\times|s|^k$ passos e que se $A(s)=1$ então $A'(s)$ devolve 1 e caso $A$(s) não responda nada (ou zero) então $A'(s)$ devolve $0$ \rightarrow $L$ é decidida em tempo polinomial.

        %==============================================================================

        Problema de Decisão

        \[\Sigma = \{0,1\}\]
        \[\Sigma^*=\{E, 0, 1, 00, 01, \ldots\}\]

        Problema $\subseteq \Sigma^* / x \in$ Problema se e somente se a resposta para instância x é sim

        Algoritmo A que decide uma linguagem L $\subset \Sigma^*$

        \[A(x) = 1  \forall x \in L\]
        \[A(x) = 0  \forall x \notin L\]

        $P = \{L \subseteq \Sigma^*$ tal que existe um algoritmo A que decide L em tempo polinomial\}

        \subsection{Verificação}

        Ciclo Hamiltoniano = \{<$G=(V,E)>$ onde G é um grafo simples e G possu um ciclo que passa por cada vértice exatamente uma vez}

        Algoritmo Verificador para uma linguagem $L \subseteq \Sigma^*$.
        $A(x, y)$ onde x é uma instância de L e y é outra string que chamamos de certificado.

        \begin{enumerate}
            \item Se $x \in L$ então $\exists y \in \Sigma^* / A(x,y) = 1$
            \item Se $x \notint L$ então $\forall y \in \Sigma^*  / A(x,y) \neq 1$
        \end{enumerate}

        \subsection{Algoritmo Verificador para Ciclo Hamiltoniano}
        A(G, sequência vertical ($v_1, v_2, \ldots, v_n$)) -> Verificar que correspondem a todos os vértices do grafo exatamente uma vez.
            For v \in (v_1, v_2, \ldots, v_n)
            If v \notin G return 0
            For i = 1 to n-1
            if(v_i,v_{i+1}) \notin G return 0
            if(v_1, v_n) \not in G return 0
            return 1

            Se G \in Ciclo-Hamiltoniano, então existe uma sequência de vérticas que corresponde ao ciclo e usamos isto como certificado.

            Se G \not in Ciclo-Hamiltoniano então na checagem das arestas, para qualquer sequência de vértices, uma aresta estará faltando.

            Um algoritmo A(x,y) verifica L \subseteq \Sigma^* em tempo polinomial se A executa em tempo polinomial em |x| e |y| e:
            \begin{enumerate}
                \item Se x \in L, então \exists y \in \Sigma^* / |y| = O(|x|^k) para k constante. A(x,y)=1
                \item Se x \notin L então \forall y \in \Sigma^* / |y| \ in O(|x|^k) temos que A(x,y) \neq 1

            \end{enumerate}

    \subsection{Classe NP}

        NP = \{L \subseteq \Sigma^* / \exists A(x,y) polinomial que verifica L\}

        Questão em aberto: P = NP?

        Exercício> P \subseteq NP

        Seja L \in P (mostrar que L \in NP) \arrowright Existe algoritmo A(x) que decide L em tempo polinomial.

        A1(x,y)
            return A(x)

        \begin{enumerate}
            \item $x \in L$, então usando $y = E$ temos que $A'(x,y) = 1$ e $|y| \in O(|x|^k)$
            \item $x \notin L$, então $A(x) = 0 \rightarrow A1(x,y) = 0$ independente do $y$.
        \end{enumerate}

    \subsection{Classe co-NP}

        Dado $L \subseteq \Sigma^*$ definimos o complemento de $l$ como
        \[\overline{L} = \Sigma^* \backslash L\]
        co-NP $= \{L \subset \Sigma^* / \overline{L} \in$ NP\}

        Instintivamente, co-NP contém as lingaguens para as quais existe algoritmo verificador polinomial para instâncias "não" do problema.
        $L \in $ co-NP se existe um algoritmo polinomial $A(x,y)$, dois quais $x$ é instância e $y$ é um certificado, onde:
        \begin{enumerate}
                \item $x \not in L, \exists y \in \Sigma^* / |y| = O(|x|^k)$ e $A(x,y) = 1$
                \item $x \in L, \forall y \in \Sigma^* / |y| = O(|x|^k)$ e $A(x,y) \neq 1$
        \end{enumerate}

        Primos \{ <n> N é um inteiro positivo e é primo\}

        Primos \in co-NP pois podemos criar um algoritmo que para cada n \neq Primos \rightarrow \exists um divisor d de n que serve como certificado polinomial que n não é primo.

        Questão em aberto> NP = co-NP ?

        Exercício: p \subseteq NP \cap co-NP (Acabamos de ver qie P \subseteq NP)
        Mostrar P \subseteq co-NP! Seja L \in P \rightarrow existe um algoritmo polinomial A(x) que decide L.

        A'(x,y)
            if A(x) == 1 return 0
            if A(x) == 0 return 1

        \begin{enumerate}
            \item $x \notin L$ então A(x,E) = 1 em tempo polinomial
            \item $x \in L$ então A(x,y)=0 independe do y.
        \end{enumerate}

        \subsection{Possíveis Relações entre estas Classes}

        P = NP \rightarrow P = NP = co-NP
        P \neq NP \rightarrow P \in NP = co-NP
        P \neq NP \rightarrow P = NP \bigcap co-NP, NP \neq co-NP
        p \neq NP \rightarrow P \subset NP \bigcap co-NP, NP \neq co-NP

        % ============= Curiosidade
        $n = p_{1}^{j_1} \times p_{2}^{j_2} \times \ldots \times p_{q}^{j_q}$
        Qualquer $n \in \Z^+$ possui uma fatoração única em primos distintos.

        RSA (ninguém consegue achar um fator de n em tempo polinomial)

        Fatoração: Dado n e m \leq n existe um fator p de n tal que $p \leq m$

        Fatoração \in P? Ninguém sabe.

        Fatoração \in co-NP e Fatoração \in NP.

        Fatoração \in NP: Dado (n,m) \in Fatoração, basta usar como certificado um fato p \leq m!
        Fatoração \in co-NP: (n,m) \notin Fatoração \rightarrow $\nexists$ fator primo p\leq m tal que p divida n. Meu certificado é uma fatoração de n em primos $p_{1}^{j_1}, p_{2}^{j_2}, \ldots, p_{q}^{j_q}$

        \begin{enumerate}
            \item Verificar que a multiplicação do valor n
                n = p_{}^{}p_{}^{}p_{}^{}

            \item Verificar que cada p_j é um número primo (feito em tempo polinomial com AKS de 2006)
            \item Verificar que cada p_j \ge m
        \end{enumerate}


\end{document}
